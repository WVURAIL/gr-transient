# GNURadio Test Benches

## List of Flow-graphs

1. Simulated pulse ->  sink
2. Simulated pulse -> Spectrometer -> sink
3. Simulated pulse -> Spectrometer -> dedisperser -> sink
4. Simulated pulse -> Spectrometer -> depdispersor -> detector -> sink
...
...
...

This section will be explaining how the completed flowgraph of the detection works. This will not explain the bench testing, which will be discussed in the next section. 

The flowgraph starts by importing the file that we wish to analyze using the file source block. The parameter asking to repeat the block is set to yes, to ensure that a steady pulse train is run through the flowgraph. The data type is whatever the instrument saving the data saved it as. Typically telescopes and other radio astronomy instuments save it as an int16/short type, so for this simulated flowgraph, that is what the data is saved as. The signal is changed into a complex type and cleaned up.

This cleaning up is done with a PFB. The PFB is created by delaying the signal, turning the stream into a vector, multiplying that vector stream by a window, and then adding together all the streams created by the delay. The first vector stream is not delayed and immediately turned into a vector. This vector length is typically the number of frequency channels that are created by taking an FFT. For the sample case, 400 channels were chosen. The next three vector streams are delayed by consecutive integer multiples of the vector stream length. Once the four vector streams are created, they are each multiplied by a different window which can be seen by clicking on the multiply constant block. The resulting vector streams are added together to create one new vector stream. 

After the signal comes out of the PFB, the FFT is taken. The forward FFT is taken to get the signal into frequency space. The tab asking if the signal is to be shifted afterwards is set to yes, so that the frequencies run from largest negative to largest positive. The window is set to rectangular by default, and the number of threads is kept at 1. The output of this block is then multiplied to its complex conjugate, using the Multiply conjugate block, and then integrated using the Integrate block. The decimation parameter in Integrate is set to `int(display_integration*samp_rate/vec_length`. The display_integration parameter needs to be a time in seconds that is less than the pulse width. So if the pulse width is .0004, the parameter needs to be at most around .0002. The sample rate parameter is the rate at which the telescope or antenna sampled the data at after downsampling. Finally the vector length parameter is the length of the vector stream, which we have previously set as 400. 

Now notice that the data now only consists of real values, so the data type can be changed to float vector. It is at this point that a throttle is introduced into the flowgraph. However it is easier to deal with streams rather than vectors with this block. This is because the throttle block *on average* regulates the number of units it allows through. Therefore, the sample rate in a vector stream can then be extrapolated.

The signal after being throttled is turned back into a vector with a length of the number of frequency channels. The vector stream is then run through another stream to vector block to turn it into a matrix. The new length of the matrix is the number of time samples that we want. This value is found by the `(number of data points in the file)/vector_length/(decimation in integrate block)`. Now that the signal is contained by matrix increments, the dedisperse_roll block is used to dedisperse the signal. The `vector length` parameter is the same as has been for the entire flowgraph. `DMS` is the vector float of the discrete DMs that should be used. The format is which this will appear is `[10,600,700]` where the numbers are arbitrary DMs that were just chosen now. Additionally, numpy.linspace can be used as well. The observing frequency is set to the centre frequency the telescope was observing at, while the bandwidth is the observing bandwidth of the telescope. The parameter `nt` is the number of time sample, the same as in the previous stream to vector block. Finally, the time length is the total observing time of the data. In the case of the simulated pulsar below, it is .15 seconds.

After the pulse is dedispersed, the signal is given to the Pulse\_Detection Block. Up to this point we have been concernig ourselves with the signal. However, the background noise must also go through the same steps. All values are kept the same and the resulting data from the dedisperse\_roll is the same noise as the baground noise of the signal. Both data sets are then used to detect the pulse in the Pulse\_Detection block. The signal and noise data goes into `in0`, while the purely noise data goes into `in1`. The `nt` parameter is the same as last time, as is the `dms` parameter. The other two parameters need to be played with to get the correct values. `pac size` is the length of each pulse packet in terms of time samples. Generally this is hard to know, but samller packet sizes tend to ensure that the pulses do not needlessly overlap. A small packet size is less than 50. The pulse width however, is unknown unless you are observing a known pulsar. Therefore for this parameter, many different pulse widths should be tried.

The output from the detection block is then given to a vector to stream block, where the number of items is the `(number of timesteps)*(len(dms))`. This is then given to a time sink. In the event that a pulsar is found, the largest pulse from the DMS that passed are given.

Some final notes about the time sinks and outputs. The vector output for the dedisperse block is the number of timesamples times the number of DMs, while the output for the detection block has a vector length of the number of time samples. The time sinks must have a sample rate equal to that of the throttle. Additionally, the throttle rate for the flowgraph is limited right now to a maximum of 1e6 samples per second when using 5 DMs. This will abe fixed in the next iteration.

